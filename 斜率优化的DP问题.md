### 斜率优化的$DP$问题

***

> 所谓的斜率优化，就是通过维护一个凸包来对决策进行优化，减少冗余的决策，使得每次的决策都是通过最优的决策转移过来。

#### 题目

##### 1.[300. 任务安排1 - AcWing题库](https://www.acwing.com/problem/content/description/302/)

> 有 $N$ 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
>
> 机器会把这 $N$ 个任务分成若干批，每一批包含连续的若干个任务。
>
> 从时刻 $0$ 开始，任务被分批加工，执行第 $i$ 个任务所需的时间是 $T_i$。
>
> 另外，在每批任务开始前，机器需要 $S$ 的启动时间，故执行一批任务所需的时间是启动时间 $S$ 加上每个任务所需时间之和。
>
> 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
>
> 也就是说，同一批任务将在同一时刻完成。
>
> 每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。
>
> 请为机器规划一个分组方案，使得总费用最小。
>
> #### 输入格式
>
> 第一行包含整数 $N$。
>
> 第二行包含整数 $S$。
>
> 接下来 $N$ 行每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间 $T_i$ 及其费用系数 $Ci$。
>
> #### 输出格式
>
> 输出一个整数，表示最小总费用。
>
> #### 数据范围
>
> $1≤N≤5000$,
> $0≤S≤50,$
> $1≤T_i,C_i≤100$
>
> #### 输入样例：
>
> ```
> 5
> 1
> 1 3
> 3 2
> 4 3
> 2 3
> 1 4
> ```
>
> #### 输出样例：
>
> ```
> 153
> ```

`分析`：感觉上是一道线性$dp$。

状态定义：$f[i]$ 表示前$i$ 个任务所有的安排方案。

属性：花费$min$

状态计算：我觉得这道题的难点就是每次进行一次任务的启动时，都会都以后的任务开始时间产生影响，那么根据动态规划的递推关系，每一次决策都不能影响到后面的决策（无后效性），直接考虑的话就会出现这种问题。

*后面的  $C_i$ 和  $T_i$ 表示对应到  $i$  位置的前缀和*

**如何消除这种影响**?， 考虑`费用提前计算` ，也就是`对后面的影响都算作本次的花费`，假如本次进行了一次开始的任务(第$i$次)，那么对于后面的任务，都会产生$s$ 时间的影响，那么这个花费就是$s(\sum_{k=i}^{n}C_k)$ 的影响，那么**对于后面时间的影响，就算作本次的花费了**，所以在后面再次考虑每次任务的开始时间时候，就不用考虑之前任务的影响了。

状态的划分:考虑最后一个任务中的小任务的数量，数量为$[1,i]$， 那么状态转移也就是

​                                     $f[i] = min(f[上次任务的终点] + 本次任务的花费$

上一个大任务的终点是$i - j$ ， 本次任务的起点是$i - j + 1$(这样长度为$j$)， 那么花费本次的花费是多少呢？ 也就是$T_i(C_i - C_{i- j}) + s(C_n - C_{i - j})$

 也就是 $f[i] = min(f[i - j] + T_i(C_i - C_{i- j}) + s(C_n - C_{i - j}))$

令$i - j = j$  那么新变量$j$的范围就为$[0,i-1]$ （我个人比较喜欢考虑最后一段的长度再来确定转移的范围确定）。



``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 5010;
typedef long long LL;
LL c[N], t[N];
int n, s;
LL f[N];


int main()
{
    cin >> n >> s;
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for(int i = 1; i <= n; i ++ )
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    for(int i = 1; i <= n; i ++ )
    {
        for(int j = 0; j < i; j ++ )
        {
            f[i] = min(f[i], f[j] + s * (c[n] - c[j]) + (t[i]) * (c[i] - c[j]));
        }
    }
    
    cout << f[n] << endl;
    return 0;
}
```



##### 2.[301. 任务安排2 - AcWing题库](https://www.acwing.com/problem/content/description/303/)

> 有 $N$ 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
>
> 机器会把这 $N $ 个任务分成若干批，每一批包含连续的若干个任务。
>
> 从时刻 $0$ 开始，任务被分批加工，执行第 i 个任务所需的时间是 $T_i$。
>
> 另外，在每批任务开始前，机器需要 $S$ 的启动时间，故执行一批任务所需的时间是启动时间 $S$ 加上每个任务所需时间之和。
>
> 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
>
> 也就是说，同一批任务将在同一时刻完成。
>
> 每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。
>
> 请为机器规划一个分组方案，使得总费用最小。
>
> #### 输入格式
>
> 第一行包含整数 $N$。
>
> 第二行包含整数 $S$。
>
> 接下来 $N$ 行每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间 $T_i $及其费用系数 $C_i$。
>
> #### 输出格式
>
> 输出一个整数，表示最小总费用。
>
> #### 数据范围
>
> $1≤N≤3×10^5$,
> $1≤T_i,C_i≤512$,
> $0≤S≤512$
>
> #### 输入样例：
>
> ```
> 5
> 1
> 1 3
> 3 2
> 4 3
> 2 3
> 1 4
> ```
>
> #### 输出样例：
>
> ```
> 153
> ```

`分析`：这道题和上道题区别就是**数据范围**的变化，$O(n^2)$ 的时间复杂度显然不能过这道题，那么就要考虑对决策进行优化。

状态转移方程：$f[i] = min(f[j] + s(C_n - C_j) + T_i(C_i - C_j))$

考虑任意的一次合法决策$j$ ， 那么$f[i] = f[j] + s(C_n - C_j) + T_i(C_i - C_j)$

对方程进行整理：$f[i] = f[j] + sC_n - (s+T_i)C_j + T_iC_i$

对于本次的决策的$i$ 而言，$sC_n+T_iC_i$ 、$(s+T_i)$ 都是常量，那么将其用常数$b,k$ 表示

那么方程就化简为$f[i] = f[j] + b - k *C_j$

看一下方程的含义：对于给定的$j$，由于是从小到大枚举的，那么对于任意的$j$ 而言，如果将$C_j$和$f[j]$ 分别看错$x$ 和 $y$ ，那么就是求 $f[i] - b = y - kx$ 的最小值，由于$b$ 是常数，可以直接看做$t = y - kx$ 的最小值，其中$x$ 和$y$  是给定的一系列的点。

作图表示为：

![image-20220108164644527](C:\Users\wxm\AppData\Roaming\Typora\typora-user-images\image-20220108164644527.png)

其中$t$  就是在这个坐标轴上的截距，只要找到这条直线截距的最小值，就是$f[i]$ 的最优决策。

此时观察图中的点，直观来看，只有最下面的点才有可能被输出，在最下面点的连线之内的所有点都不可能作为答案输出，然后就可以进行优化了，将他们都去除，最终形成了一下下凸包。

那么这次的最优决策应该是什么呢？假设已经维护了一个下凸包

![image-20220108165503917](C:\Users\wxm\AppData\Roaming\Typora\typora-user-images\image-20220108165503917.png)

此时，$t = y - kx$的直线为最下方的红色直线，三条直线的斜率分别为$k_1,k_2,k_3$，那

么当$k_1\lt k \lt k2$ 的时候，$k_1$ 就不可能作为答案输出。

也就是在一系列的直线中找到第一个大于等于斜率为$k$ 的直线，可以使用二分来做。

对于本道题而言，找到相当于是一个区间内部的满足条件的最小值，直接维护这个最小值即可，可以使用单调队列进行优化。不用使用二分

由于本道题每次增加的点都是靠右侧的，也就是$x$ 不断增大，为了继续维护这个凸包，所以在插入新的点的时候，对于不满足条件的点进行剔除即可。

通过上面的分析：队头队尾出队的条件已经很明确了

对于对头：只要斜率小于$k$ ,就进行出队。

对于队尾：只要加入点的斜率与队尾形成直线的斜率小于之前队尾的斜率，队尾就出队。

**队列中记录的是下标**

队头：$\frac{f[q[hh]] - f[q[hh + 1]]}{C_{q[hh]} - C_{q[hh + 1]}} \le s+ T_i$

队尾：$\frac{f[i] - f[q[tt]]}{C_i - C_{q[tt]}} <= \frac{f[q[tt]] - f[q[tt - 1]]}{C_{q[tt]} - C_{q[tt - 1]}}$

``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 3e5 + 10;
typedef long long LL;
LL f[N], t[N], c[N];
int n, s;
int q[N];

int main()
{
    cin >> n >> s;
    for(int i = 1; i <= n; i ++ )
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    int hh = 0, tt = 0;
    memset(f,0x3f,sizeof f);
    f[0] = 0;
    
    for(int i = 1; i <= n; i ++ )
    {
        while(hh < tt && f[q[hh + 1]] - f[q[hh]] <= (s + t[i]) *\
                         (c[q[hh + 1]] - c[q[hh]])) hh ++;
        
        int j = q[hh];
        f[i] = f[j] + s * (c[n] - c[j]) + t[i] * (c[i] - c[j]);
        while(hh < tt && (f[i] - f[q[tt]]) * (c[q[tt]] - c[q[tt - 1]]) \
                    <= (f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt]])) tt--;
        q[++ tt] = i; 
    }
    cout << f[n] <<endl;
    return 0;
}
```

##### 3. [302. 任务安排3 - AcWing题库](https://www.acwing.com/problem/content/description/304/)

> 有 $N$ 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
>
> 机器会把这 $N$ 个任务分成若干批，每一批包含连续的若干个任务。
>
> 从时刻 00 开始，任务被分批加工，执行第 ii 个任务所需的时间是 $T_i$。
>
> 另外，在每批任务开始前，机器需要 SS 的启动时间，故执行一批任务所需的时间是启动时间 SS 加上每个任务所需时间之和。
>
> 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
>
> 也就是说，同一批任务将在同一时刻完成。
>
> 每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。
>
> 请为机器规划一个分组方案，使得总费用最小。
>
> #### 输入格式
>
> 第一行包含两个整数 $N$ 和 $S$。
>
> 接下来 $N$ 行每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间 $T_i$ 及其费用系数 $C_i$。
>
> #### 输出格式
>
> 输出一个整数，表示最小总费用。
>
> #### 数据范围
>
> $1≤N≤3×10^5$,
> $0≤S,C_i≤512$,
> $−512≤T_i≤512$
>
> #### 输入样例：
>
> ```
> 5 1
> 1 3
> 3 2
> 4 3
> 2 3
> 1 4
> ```
>
> #### 输出样例：
>
> ```
> 153
> ```

`分析` ：和上面第二题基本一样，查询操作变为二分而已（数据加强了需要使用double强转）



``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 3e5 + 10;
typedef long long LL;
LL f[N], t[N], c[N];
int n, s;
int q[N];


int main()
{
    cin >> n >> s;
    for(int i = 1; i <= n; i ++ )
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    int  tt = 0;
    memset(f,0x3f,sizeof f);
    f[0] = 0;
    
    for(int i = 1; i <= n; i ++ )
    {
        int l = 0, r = tt;
        while(l < r)
        {   
            int mid = l + r >> 1;
            if((f[q[mid + 1]] - f[q[mid]] >= (c[q[mid + 1]] - c[q[mid]]) * (s + t[i]))) r = mid;
            else l = mid + 1;
        }
        int j = q[l];
        f[i] = f[j] + s * (c[n] - c[j]) + t[i] * (c[i] - c[j]);
        while(tt && (double)(f[i] - f[q[tt]]) * (c[q[tt]] - c[q[tt - 1]]) \
        <= (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt]])) tt--;
        q[++ tt] = i; 
    }
    cout << f[n] <<endl;
    return 0;
}
```

