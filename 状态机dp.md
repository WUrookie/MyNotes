### 状态机$dp$

****

> 状态机模型：也就是将状态的划分变成了状态机的模样，通过绘制完状态机，整个状态之间的转移就比较清晰了。
>

#### 题目

##### 1. [打家劫舍.LeetCode](https://leetcode-cn.com/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
>  
>
> 示例 1：
>
> 输入：$[1,2,3,1]$
> 输出：$4$
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> 示例 2：
>
> 输入：$[2,7,9,3,1]$
> 输出：$12$
> 解释：偷窃 $1$ 号房屋 (金额 = $2$), 偷窃 $3$ 号房屋 (金额 = $9$)，接着偷窃 $5$ 号房屋 (金额 = $1$)。
>      偷窃到的最高金额 : $2 + 9 + 1 = 12$ 。
>
>
> 提示：
>
> $1 <= nums.length <= 100$
> $0 <= nums[i] <= 400$

绘制一下状态机： ![FCF163D9DB962790AC1CA7411A07803A](D:\QQ数据\473570721\FileRecv\MobileFile\FCF163D9DB962790AC1CA7411A07803A.png)

所有待更新的状态就两个，状态转移有四项

``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1E5 + 10;
int f[N][2];
int n;
int w[N];


int main()
{
    int t;
    cin >> t;
    while(t -- )
    {
        cin >> n;
        for(int i = 1; i <= n; i ++ ) cin >> w[i];
        memset(f, 0xcf, sizeof f);
        f[0][0] = 0;
        f[0][1] = 0;
        for(int i = 1; i <= n; i ++ )
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + w[i];
        }
        cout << max(f[n][0], f[n][1]) << endl;
    }
    return 0;
}
```

##### 2.[股票买卖 II](https://www.acwing.com/problem/content/1057/)

> 给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> #### 输入格式
>
> 第一行包含整数 $N$，表示数组长度。
>
> 第二行包含 $N$ 个不大于 $10000$ 的正整数，表示完整的数组。
>
> #### 输出格式
>
> 输出一个整数，表示最大利润。
>
> #### 数据范围
>
> $1≤N≤10^5$
>
> #### 输入样例1：
>
> ```
> 6
> 7 1 5 3 6 4
> ```
>
> #### 输出样例1：
>
> ```
> 7
> ```
>
> #### 输入样例2：
>
> ```
> 5
> 1 2 3 4 5
> ```
>
> #### 输出样例2：
>
> ```
> 4
> ```
>
> #### 输入样例3：
>
> ```
> 5
> 7 6 4 3 1
> ```
>
> #### 输出样例3：
>
> ```
> 0
> ```
>
> #### 样例解释
>
> 样例1：在第 $2$ 天（股票价格 = $1$）的时候买入，在第 $3$ 天（股票价格 = $5$）的时候卖出, 这笔交易所能获得利润 = $5-1 = 4$ 。随后，在第 $4$ 天（股票价格 = $3$）的时候买入，在第 $5$ 天（股票价格 = $6$）的时候卖出, 这笔交易所能获得利润 = $6-3 = 3$ 。共得利润 $4+3 = 7$。
>
> 样例2：在第 $1$天（股票价格 = $1$）的时候买入，在第 $5$ 天 （股票价格 = $5$）的时候卖出, 这笔交易所能获得利润 = $5-1 = 4$ 。注意你不能在第 $1$ 天和第 $2$ 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>
> 样例3：在这种情况下, 不进行任何交易, 所以最大利润为 $0$。

绘制出状态机：![ADBAC21CCE999C04F2B242CC71B8C88C](D:\QQ数据\473570721\FileRecv\MobileFile\ADBAC21CCE999C04F2B242CC71B8C88C.png)

``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1E5 + 10;
int f[N][2];
int n;
int w[N];

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++ ) cin >> w[i];
    // 初始化不合法状态
    f[0][1] = -1e9;
    for(int i = 1; i <= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][1] + w[i]);
        f[i][1] = max(f[i - 1][1], f[i - 1][0] - w[i]);
    }
    cout << f[n][0] << endl;
    return 0;
}
```



##### 3.[股票买卖Ⅳ](https://www.acwing.com/problem/content/description/1059/)

> 给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第$ i$ 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润，你最多可以完成$ k$ 笔交易。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。
>
> #### 输入格式
>
> 第一行包含整数 $N$ 和 $k$，表示数组的长度以及你可以完成的最大交易数量。
>
> 第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。
>
> #### 输出格式
>
> 输出一个整数，表示最大利润。
>
> #### 数据范围
>
> $1≤N≤10^5$,
> $1≤k≤100$
>
> #### 输入样例1：
>
> ```
> 3 2
> 2 4 1
> ```
>
> #### 输出样例1：
>
> ```
> 2
> ```
>
> #### 输入样例2：
>
> ```
> 6 2
> 3 2 6 5 0 3
> ```
>
> #### 输出样例2：
>
> ```
> 7
> ```
>
> #### 样例解释
>
> 样例1：在第 $1$ 天 (股票价格 = $2$) 的时候买入，在第 $2$ 天 (股票价格 = $4$) 的时候卖出，这笔交易所能获得利润 = $4-2 = 2$ 。
>
> 样例2：在第 $2$ 天 (股票价格 = $2$) 的时候买入，在第 $3$ 天 (股票价格 = $6$) 的时候卖出, 这笔交易所能获得利润 =$ 6-2 = 4 $。随后，在第 $5$ 天 (股票价格 = $0$) 的时候买入，在第 $6$ 天 (股票价格 = $3$) 的时候卖出, 这笔交易所能获得利润 = $3-0 = 3$ 。共计利润 $4+3 = 7$.

绘制出状态机：

![ADBAC21CCE999C04F2B242CC71B8C88C](D:\QQ数据\473570721\FileRecv\MobileFile\ADBAC21CCE999C04F2B242CC71B8C88C.png)

但是这道题多出了最多进行$k$次交易的限制，所以要考虑状态之间是如何转移的

**第一种状态定义方式**:$f[i][j][0/1] 表示考虑前 i 天， 进行了 j 次交易，当前手中有无股票的集合$

```c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1E5 + 10, M = 110;
int f[N][M][2];
int w[N];
int n, m;

int main()
{
    cin >> n >> m;
    // f[i][j][0/1] 表示考虑前 i 天， 进行了 j 次交易，当前手中有无股票的集合
    // 属性，max
    for(int i = 1; i <= n; i ++ ) cin >> w[i];
    memset(f, 0xcf, sizeof f);
    f[0][0][0] = 0;
    for(int i = 1; i <= n; i ++ )
        for(int j = 0; j <= m; j ++ )
        {
            f[i][j][0] = f[i - 1][j][0];
            if(j) f[i][j][0] = max(f[i][j][0], f[i - 1][j - 1][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j][0] - w[i]);
            
        }
    int ans = 0;
    for(int i = 1; i <= m; i ++ ) ans = max(ans, f[n][i][0]);
    cout << ans;
    return 0;
}
```

**第二种状态定义的方式**：$f[i][j][0/1] 表示考虑前 i 天， 正在进行第 j 次交易，当前手中有无股票的集合$

``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1E5 + 10, M = 110;
int f[N][M][2];
int w[N];
int n, m;

int main()
{
    cin >> n >> m;
    // f[i][j][0/1] 表示考虑前 i 天， 正在进行第 j 次交易，当前手中有无股票的集合
    // 属性，max
    for(int i = 1; i <= n; i ++ ) cin >> w[i];
    memset(f, 0xcf, sizeof f);
    for(int i = 0;i <= n;i++) f[i][0][0] = 0;
    for(int i = 1; i <= n; i ++ )
        for(int j = 1; j <= m; j ++ )
        {
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
        }
    int ans = 0;
    for(int i = 1; i <= m; i ++ ) ans = max(ans, f[n][i][0]);
    cout << ans;
    return 0;
}
```

`可以发现，两种不同的状态定义方式，在状态转移的时候会出现细微的区别。在我个人看来，正在进行这个状态是不太好描述的，所以尽量还是使用完成了这种状态定义思考起来比较简单`

##### 4.[捡苹果.PaPaMelon](https://www.papamelon.com/problem/306)

> 最开始 $Bessie$ 站在树 $1$ 下面, 每一个单位时间有颗苹果从树 $1$ 或者树 $2$ 上落下来。
>
> 每个单位时间 $Bessie$ 可以移动一次位置, 时间长度为$T$, Bessie 最多移动 $W$ 次。
>
> 求 $Bessie$ 最多能得到多少苹果
>
> 
>
> - 每组测试数据第一行有两个整数 $T$($1 \leq T \leq 1000$), $W$($1 \leq W \leq 30$)$T$($1≤*T*≤1000$),$W$($1≤*W*≤30$)
> - 接下来的 $T$ 行每行有一个整数 $1$ 或 $2$, 表示苹果是从哪个树掉落
>
> - 一个整数，表示最多能得到多少苹果
>
> 
>
> 输入
>
> ```
> 7 2
> 2
> 1
> 1
> 2
> 2
> 1
> 1
> ```
>
> 输出
>
> ```
> 6
> ```

绘制出状态机：

![80B2FF231606404BEE513E6E347AB812](D:\QQ数据\473570721\FileRecv\MobileFile\80B2FF231606404BEE513E6E347AB812.png) 

这道题需要注意的是状态的初始化和合法性

```  c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1010, M = 33;
int f[N][M][2];
int n, m;
int w[N];
int ans;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++ ) 
    {
        cin >> w[i];
        w[i]--;
    }
    if(w[1]) f[1][1][1] = 1;
    else f[1][0][0] = 1;
    // f[i][j][0/1] 表示考虑前 i 个小时，走了 j 步，当前处在 [1/2]号树下可以获得的最大价值 
    for(int i = 2; i <= n; i ++ )
        for(int j = 0; j <= m; j ++ )
        {
            if(w[i]) // 如果在二号树下
            {
                f[i][j][0] = f[i - 1][j][0];
                if(j) f[i][j][0] = max(f[i][j][0], f[i - 1][j - 1][1] + 1);
                f[i][j][1] = f[i - 1][j][1] + 1;
                if(j) f[i][j][1] = max(f[i - 1][j - 1][0] + 1, f[i][j][1]);
            }
            else
            {
                f[i][j][0] = f[i - 1][j][0] + 1;
                if(j) f[i][j][0] = max(f[i][j][0], f[i - 1][j - 1][1] + 1);
                f[i][j][1] = f[i - 1][j][1];
                if(j) f[i][j][1] = max(f[i][j][1], f[i - 1][j - 1][0] + 1);
            }
            // 如果为奇数步，那么在 1 号树下是非法的
            if( j % 2) f[i][j][0] = 0;
            else f[i][j][1] = 0;
        }
    
    for(int i = 0; i <= m; i ++ ) ans = max(ans, max(f[n][i][0], f[n][i][1]));
    cout << ans;
    return 0;
}
```



##### 5.[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

> 给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>
> **示例:**
>
> ```
> 输入: [1,2,3,0,2]
> 输出: 3 
> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
> ```

绘制出状态机，这里需要多一个状态进行表示：

![F074F576599A927D9BF8749588EB34C2](D:\QQ数据\473570721\FileRecv\MobileFile\F074F576599A927D9BF8749588EB34C2.png)

``` C++
class Solution {
public:
    int maxProfit(vector<int>& w) {
        int n = w.size();
        vector<vector<int>> f(n + 1, vector<int>(3));
        f[0][1] = f[0][0] = -1e9;
        
        for(int i = 1; i <= n; i ++ )
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i - 1]);
            f[i][1] = f[i - 1][0] + w[i - 1];
            f[i][2] = max(f[i - 1][2], f[i - 1][1]);
        }
        return max(f[n][1], f[n][2]);
    }
};
```



##### 6.[PAT 计数](https://www.acwing.com/problem/content/1585/)

> 字符串 `APPAPT` 中共包含两个 `PAT` 作为子串。
>
> 第一个子串由第二，第四和第六个字符组成，第二个子串由第三，第四和第六个字符组成。
>
> 现在给定一个字符串，请你求出字符串中包含的 `PAT` 的数量。
>
> #### 输入格式
>
> 共一行，包含一个由大写字母 $P,A,T$ 构成的字符串。
>
> #### 输出格式
>
> 输出字符串中包含的 `PAT` 的数量。
>
> 由于结果可能很大，请你输出对 $1000000007$取模后的结果。
>
> #### 数据范围
>
> 给定字符串的长度不超过 $10^5$。
>
> #### 输入样例：
>
> ```
> APPAPT
> ```
>
> #### 输出样例：
>
> ```
> 2
> ```

绘制出状态机：

![7A0C420AE421311118D5530FCF83522A](D:\QQ数据\473570721\FileRecv\MobileFile\7A0C420AE421311118D5530FCF83522A.png)

``` c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1e5 + 10, mod = 1000000007;
int f[N][3];
string s;
int n;
// 优化为三个变量也行，而且写的比较好看
int main()
{
    cin >> s;
    n = s.size();
    s = ' ' + s;
    for(int i = 1; i <= n; i ++ )
    {
        char ch = s[i];
        f[i][0] = f[i - 1][0] + (ch == 'P' ? 1: 0);
        f[i][1] = f[i - 1][1] + (ch == 'A' ? f[i - 1][0] : 0);
        f[i][2] = f[i - 1][2] + (ch == 'T' ? f[i - 1][1] : 0);
        for(int j = 0; j < 3; j ++ ) f[i][j] %= mod;
    }
    cout << f[n][2] << endl;
    return 0;
}
```

