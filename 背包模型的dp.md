### 背包模型的$dp$

> 常见的背包问题：
>
> 01 背包、 完全背包、 完全背包、分组背包、多重背包、有依赖的背包（树形$dp$）
>
> 他们这些状态转移方程基本上是一致的：
>
> $f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w,...)$
>
> 其中完全背包可以优化成$f[i][j] = max(f[i - 1][j], f[i][j -v] + w)$
>
> 划分的依据都是第$i$ 个物品选或者不选，就有了上面的状态转移方程
>
> 
>
> 其中这些问题的考点可以是：
>
> · 体积不超过 $j$ 的最大价值，方案数，~~最小价值~~(不存在)
>
> · 体积恰好为 $j$ 的最大价值，方案数，最小价值
>
> ` 体积至少为$j$ 的~~最大价值~~（不存在），方案数，最小价值
>
> 这三种的唯一的区别就是初始化的时候不一样。
>
> **体积不超过 $j$ 的最大价值**： $f[i][j] = 0$      $(0\le i \le n, 0 \le j \le m)$ 
>
> **体积恰好为 $j$ 的最大价值**:    $f[i][j] = -INF$     $(i,j \ne 0)$  $f[0][0] = 0$
>
> **体积至少为$j$ 的最大价值**:  这种情况不存在
>
>  
>
> **体积不超过 $j$ 的方案数**：  $f[0][i] = 1$     $(0 \le i \le m)$
>
> **体积恰好为 $j$ 的方案数** :    $f[0][0] = 1$ 
>
> **体积至少为 $j$ 的方案数**：  $f[0][0] = 1$   
>
>  
>
> **体积不超过 $j$ 的最小价值**： 不存在
>
> **体积恰好为 $j$ 的最小价值** :    $f[i][j] = INF$      $(i,j \ne 0)$  $f[0][0] = 0$
>
> **体积至少为 $j$ 的最小价值**：  $f[i][j] = INF$        $(i,j \ne 0)$  $f[0][0] = 0$
>
> 
>
> 一维的情况类比即可。
>
> 还有就是背包问题的体积和价值可以互换，见后页

***

#### 题目

##### 1.[01背包求最大价值](https://www.acwing.com/problem/content/2/)

> 有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
>
> 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数$N，V $用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> $0<N,V≤1000$
> $0<v_i,w_i≤1000$
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 5
> ```
>
> #### 输出样例：
>
> ```
> 8
> ```



``` c++
#include <iostream>

using namespace std;
const int N = 1010;
int f[N];
int n, m;

int main()
{
    cin >> n >> m ;
    for(int i = 0 ; i < n ; i ++ )
    {
        int v, w;
        
        cin >> v >> w;
        for(int j = m ; j >= v ; j -- )
            f[j] = max(f[j] , f[j - v] + w);
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```

##### 2.[完全背包求最大价值](https://www.acwing.com/problem/content/3/)

> 有 $N$ 件物品和一个容量是 $V$ 的背包。每种物品都有无限件可用。
>
> 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数$N，V $用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> $0<N,V≤1000$
> $0<v_i,w_i≤1000$
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 5
> ```
>
> #### 输出样例：
>
> ```
> 10
> ```

``` c++
#include <iostream>

using namespace std;
const int N = 1010;
int f[N];
int n, m;
// f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w ... , f[i][j - s*v] + s * w)
// f[i][j - v] = max(f[i - 1][j - v], ... f[i - 1][j - (s - 1) * v] + (s - 1)* w)
// 替换得到  f[i][j] = max(f[i - 1][j], f[i][j - v] + w)
int main()
{
    cin >> n >> m ;
    for(int i = 0 ; i < n ; i ++ )
    {
        int v, w;
        
        cin >> v >> w;
        for(int j = v ; j <= m ; j ++ )
            f[j] = max(f[j] , f[j - v] + w);
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```

##### 3.[多重背包求最大价值](https://www.acwing.com/problem/content/5/)

> 有 $N $种物品和一个容量是 $V$ 的背包。
>
> 第 ii 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数，$N，V$用空格隔开，分别表示物品种数和背包容积。
>
> 接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> $0<N≤1000$
> $0<V≤2000$
> $0<v_i,w_i,s_i≤2000$
>
> ##### 提示：
>
> 本题考查多重背包的二进制优化方法。
>
> #### 输入样例
>
> ```
> 4 5
> 1 2 3
> 2 4 1
> 3 4 3
> 4 5 2
> ```
>
> #### 输出样例：
>
> ```
> 10
> ```

``` c++
// 二进制优化,多重背包考虑的是第 i 个物品选几个，这里直接写二进制优化的代码

#include <iostream>
#include <cstring>

using namespace std;
const int N = 2010;
int f[N];
int n, m;

int main()
{
    cin >> n >> m;
    while(n -- )
    {
        int v, w, s;
        cin >> v >> w >> s;
        
        for(int k = 1; k <= s; k <<= 1)
        {
            for(int j = m; j >= k * v; j --)
                f[j] = max(f[j], f[j - k * v] + k * w);
            
            s -= k;
        }
        if(s)
            for(int j = m; j >= s * v; j --)
                f[j] = max(f[j], f[j - s * v] + s * w);
    }
    cout << f[m];
    return 0;
}

```

##### 4.[01背包求最优选法的方案数](https://www.acwing.com/problem/content/11/)

> 有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
>
> 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
>
> 输出 **最优选法的方案数**。注意答案可能很大，请输出答案模 $109+7$的结果。
>
> #### 输入格式
>
> 第一行两个整数$N，V$，用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。
>
> #### 输出格式
>
> 输出一个整数，表示 **方案数** 模 $10^9+7$ 的结果。
>
> #### 数据范围
>
> $0<N,V≤1000$
> $0<v_i,w_i≤1000$
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 6
> ```
>
> #### 输出样例：
>
> ```
> 2
> ```

``` c++
// 求方案数的时候不可以优化空间
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1010, mod = 1e9 + 7;
int f[N][N], g[N][N];
int n, m;

int main()
{
    cin >> n >> m;
    g[0][0] = 1;
    for(int i = 1; i <= n; i ++ )
    {
        int v, w;
        cin >> v >> w;
        for(int j = 0; j <= m; j ++ )
        {
            int maxv = f[i - 1][j];
            if(j >= v) maxv = max(maxv, f[i - 1][j - v] + w);
            if(maxv == f[i - 1][j]) g[i][j] = (g[i][j] + g[i - 1][j]) % mod;
            if(j >= v && maxv == f[i - 1][j - v] + w) g[i][j] = (g[i][j] + g[i - 1][j - v]) % mod;
            f[i][j] = maxv;
        }
        
    }
    int res = 0;
    for(int i = 0; i <= m; i ++ ) if(f[n][m] == f[n][i]) res = (res + g[n][i]) % mod;
    cout << res << endl;
    return 0;
}
```

##### 5.[完全背包求方案数](https://leetcode-cn.com/problems/coin-change-2/)

> 给你一个整数数组 $coins$ 表示不同面额的硬币，另给一个整数 $amount$ 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 $0$ 。
>
> 假设每一种面额的硬币有无限个。 
>
> 题目数据保证结果符合 32 位带符号整数。
>
>  
>
> 示例 1：
>
> ``` c++
> 输入：amount = 5, coins = [1, 2, 5]
> 输出：4
> 解释：有四种方式可以凑成总金额：
> ```
>
>
> 提示：
>
> $1 <= coins.length <= 300$
> $1 <= coins[i] <= 5000$
> $coins$ 中的所有值 互不相同
> $0 <= amount <= 5000$

``` c++
const int N = 5010;
class Solution {
public:
    int f[N];
    int change(int m, vector<int>& coins) {
        memset(f, 0, sizeof f);
        f[0] = 1;
        int n = coins.size();
        for(int i = 0; i < n; i ++ )
            for(int j = coins[i]; j <= m; j ++ )
                f[j] +=f[j - coins[i]];
        
        return f[m];
    }
};
```

##### 6.[背包问题求具体方案](https://www.acwing.com/problem/content/12/)

> 有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
>
> 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
>
> 输出 **最优选法的方案数**。注意答案可能很大，请输出答案模 $109+7$的结果。
>
> #### 输入格式
>
> 第一行两个整数$N，V$，用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。
>
> #### 输出格式
>
> 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。
>
> 物品编号范围是 $1…N$。
>
> #### 数据范围
>
> $0<N,V≤1000$
> $0<v_i,w_i≤1000$
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 6
> ```
>
> #### 输出样例：
>
> ```
> 1 4
> ```

``` c++
// 背包问题求具体方案就是相当于最短路问题求路径，将每个状态看成一个节点，状态之间的//转移看成图中的一条边，也就是相当于求图中从起点走到终点的路径
// 这里的实现也和最短路问题一样
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1010;
int f[N][N];
bool g[N][N];
int n, m;
int v[N], w[N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for(int i = n; i ; i -- )
        for(int j = 0; j <= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            g[i][j] = false;
            if(j >= v[i] && f[i + 1][j - v[i]] + w[i] >= f[i][j]) 
            {
                g[i][j] = true;
                f[i][j] = f[i + 1][j - v[i]] + w[i];
            }
        }
    int j = m;
    for(int i = 1; i <= n; i ++ )
    {
        if(g[i][j])
        {
            cout << i <<' ';
            j -= v[i];
        }
    }
    return 0;
}
```

##### 7.[分组背包求具体方案](https://www.acwing.com/solution/content/4664/)

> 总公司拥有$M$台 **相同** 的高效设备，准备分给下属的$N$个分公司。
>
> 各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。
>
> 问：如何分配这M台设备才能使国家得到的盈利最大？
>
> 求出最大盈利值。
>
> 分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数$M$。
>
> #### 输入格式
>
> 第一行有两个数，第一个数是分公司数$N$，第二个数是设备台数$M$；
>
> 接下来是一个$N*M$的矩阵，矩阵中的第$ i$ 行第 $j$ 列的整数表示第 $i$ 个公司分配 $j$ 台机器时的盈利。
>
> #### 输出格式
>
> 第一行输出最大盈利值；
>
> 接下$N$行，每行有$2$个数，即分公司编号和该分公司获得设备台数。
>
> 答案不唯一，输出任意合法方案即可。
>
> #### 数据范围
>
> $1≤N≤10$,
> $1≤M≤15$
>
> #### 输入样例：
>
> ```
> 3 3
> 30 40 50
> 20 30 50
> 20 25 30
> ```
>
> #### 输出样例：
>
> ```
> 70
> 1 1
> 2 1
> 3 1
> ```

``` c++
// 不考虑字典序
#include <iostream>
#include <cstring>

using namespace std;
const int N = 16;
int g[N][N];
int f[N][N], a[N][N];
int n, m;

void print(int x, int y)
{
    if(!x) return;
    int k = g[x][y];
    print(x - 1, y - k);
    cout << x <<' ' << k << endl;
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++ )
        for(int j = 1; j <= m; j ++ ) cin >> a[i][j];
    
    for(int i = 1; i <= n; i ++ )
        for(int j = 0; j <= m; j ++ )
            for(int k = 0; k <= j; k ++ )
            {
                int maxv = f[i - 1][j - k] + a[i][k];
                if(maxv > f[i][j])
                {
                    f[i][j] = maxv;
                    g[i][j] = k;
                }
            }
    cout << f[n][m] << endl;
    print(n, m);
    return 0;
}
```

##### 7.[能量石](https://www.acwing.com/problem/content/736/)

> 岩石怪物杜达生活在魔法森林中，他在午餐时收集了$N$ 块能量石准备开吃。
>
> 由于他的嘴很小，所以一次只能吃一块能量石。
>
> 能量石很硬，吃完需要花不少时间。
>
> 吃完第 $i$ 块能量石需要花费的时间为 $S_i$秒。
>
> 杜达靠吃能量石来获取能量。
>
> 不同的能量石包含的能量可能不同。
>
> 此外，能量石会随着时间流逝逐渐失去能量。
>
> 第 $i$ 块能量石最初包含 $E_i$ 单位的能量，并且每秒将失去 $L_i$ 单位的能量。
>
> 当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。
>
> 能量石中包含的能量最多降低至 $0$。
>
> 请问杜达通过吃能量石可以获得的最大能量是多少？
>
> #### 输入格式
>
> 第一行包含整数$T$，表示共有 $T$ 组测试数据。
>
> 每组数据第一行包含整数 $N$，表示能量石的数量。
>
> 接下来 $N$ 行，每行包含三个整数 $S_i,E_i,L_i$。
>
> #### 输出格式
>
> 每组数据输出一个结果，每个结果占一行。
>
> 结果表示为 `Case #x: y`，其中 $x$ 是组别编号（从 $1$ 开始），$y$ 是可以获得的最大能量值。
>
> #### 数据范围
>
> $1≤T≤10$,
> $1≤N≤100$,
> $1≤Si≤100$,
> $1≤Ei≤10^5$,
> $0≤Li≤10^5$
>
> #### 输入样例：
>
> ```
> 3
> 4
> 20 10 1
> 5 30 5
> 100 30 1
> 5 80 60
> 3
> 10 4 1000
> 10 3 1000
> 10 8 1000
> 2
> 12 300 50
> 5 200 0
> ```
>
> #### 输出样例：
>
> ```
> Case #1: 105
> Case #2: 8
> Case #3: 500
> ```
>
> #### 样例解释
>
> 在样例＃1中，有 $N=4$ 个宝石。杜达可以选择的一个吃石头顺序是：
>
> - 吃第四块石头。这需要 $5$ 秒，并给他 $80$ 单位的能量。
> - 吃第二块石头。这需要 $5$ 秒，并给他 $5$ 单位的能量（第二块石头开始时具有 $30$单位能量，$5$ 秒后失去了 $25$ 单位的能量）。
> - 吃第三块石头。这需要 $100$秒，并给他 $20$ 单位的能量（第三块石头开始时具有 $30$ 单位能量，$10$ 秒后失去了 $10$ 单位的能量）。
> - 吃第一块石头。这需要 $20$ 秒，并给他 $0$ 单位的能量（第一块石头以 $10$ 单位能量开始，$110$ 秒后已经失去了所有的能量）。
>
> 他一共获得了 $105$ 单位的能量，这是能获得的最大值，所以答案是 105105。
>
> 在样本案例＃$2$中，有 $N=3$ 个宝石。
>
> 无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。
>
> 所以他应该吃第三块石头，给他提供 88 单位的能量。
>
> 在样本案例＃$3$中，有 $N=2$ 个宝石。杜达可以：
>
> - 吃第一块石头。这需要 $12$ 秒，并给他 $300$ 单位的能量。
> - 吃第二块石头。这需要 $5$ 秒，并给他 $200$ 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。
>
> 所以答案是 $500$。

`分析`：考虑以什么样的顺序吃这个能量石, 假设之前经过了 $T$ 的时间，
此时 $a[i] a[j] $的能量分别为 $e[i] - T * l[i]$          $e[j] - T * l[j] $ 

第一种顺序获得的能量为    $a[i]$   $a[j]$

$e[i] - T * l[i] + e[j] - (T + t[i]) * l[j]$
第二种顺序获得的能量为    $a[j] $  $a[i]$
$e[j] - T * l[j] + e[i] - (T + t[j]) * l[i]$
假设第一种能量比第二种能量获得的要多，则需要满足什么条件？
$t[i] * l[j] - t[j] * l[i] \ge 0$
所以考虑这个顺序来吃石头

然后每个能量是可以选择吃或者不吃，就变成了背包问题

``` c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 10010;
struct Node
{
    int e, t, l;
    bool operator < (const Node& n) const
    {
        return t * n.l < n.t * l;
    }
}a[N];
int f[N];
int n;

int main()
{
    int t;
    cin >> t;
   for(int k = 1; k <= t; k ++ )
    {
        cin >> n;
        int sum = 0;
        for(int i = 1; i <= n; i ++ ) 
        {
            cin >> a[i].t >> a[i].e >> a[i].l;
            sum += a[i].t;
        }
        sort(a + 1, a + 1 + n);
        memset(f, 0, sizeof f);
        for(int i = 1; i <= n; i ++ )
            for(int j = sum; j >=a[i].t; j --)
            f[j] = max(f[j], f[j - a[i].t] + a[i].e - (j - a[i].t) * a[i].l); // 这里需要注意一下，假设吃完的时刻是 j 的话，那么开始吃的时刻就是上式
        
        int res =0;
        for(int i = 0 ; i<= sum ; i ++) res = max(res, f[i]);
        printf("Case #%d: %d\n",k,res );
    }
    return 0;
}
```

